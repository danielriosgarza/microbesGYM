episode:
  mix: {enabled: true, short_horizon: 10, long_horizon: 500, short_prob: 0.1}
  dt_hours: 1.0
  training_mode: fast

simulation:
  min_steps_per_pulse: 10
  steps_per_hour_factor: 50

actions:
  pH_mode: emergent
  actuators:
    - {name: q,    type: continuous}
    - {name: v,    type: continuous}
    - {name: stir, type: continuous}
    - {name: temp, type: continuous}
  bounds:
    q:    [0.0, 0.2]
    v:    [0.0, 0.1]
    stir: [0.0, 1.0]
    temp: [25.0, 45.0]

observations:
  include: [met.all, pH.used, actuator_echo.all, met.delta.all, met.rate.all]
  pipeline:
    - normalize: {method: running_mean_var, clip: [-5, 5]}
    - clip: {min: -10, max: 10}

rewards:
  error_reward: -1000.0

  terms:
    # 1) SHORT — always increase from random starts (your Option-B, unchanged)
    - {expr: "gate(abs(delta(met['butyrate'])), 0.02, clip((delta(met['butyrate']) + abs(delta(met['butyrate'])))/2, 0, 0.2)) / kpi.horizon", weight: 200.0, when: short}
    - {expr: "- gate(abs(delta(met['butyrate'])), 0.02, clip((abs(delta(met['butyrate'])) - delta(met['butyrate']))/2, 0, 0.2)) / kpi.horizon", weight: 300.0, when: short}

    # 2) LONG — linear benefit for increases, penalize decreases (same form, gentler weights)
    - {expr: "gate(abs(delta(met['butyrate'])), 0.02, clip((delta(met['butyrate']) + abs(delta(met['butyrate'])))/2, 0, 0.2)) / kpi.horizon", weight: 150.0, when: long}
    - {expr: "- gate(abs(delta(met['butyrate'])), 0.02, clip((abs(delta(met['butyrate'])) - delta(met['butyrate']))/2, 0, 0.2)) / kpi.horizon", weight: 225.0, when: long}

    # (kept) Small per-step level shaping above 8 (tiny effect; OK to keep)
    - {expr: "(clip(met['butyrate'] - 8.0, 0, 1e9) ** 1.0) / kpi.horizon", weight: 0.75}

    # (kept) Control costs
    - {expr: "(action.q * dt_hours) / kpi.horizon",  weight: -0.015}
    - {expr: "(action.v) / kpi.horizon",              weight: -0.025}
    - {expr: "(abs(action.temp - 37)) / kpi.horizon", weight: -0.015}
    - {expr: "(action.stir) / kpi.horizon",           weight: -0.008}

  terminal:
    # Laddered terminal gradient: 5→6, 6→7, 7→8
    - {expr: "clip((met['butyrate'] - 5.0) / 1.0, 0, 1.0)", weight: 6.0}
    - {expr: "clip((met['butyrate'] - 6.0) / 1.0, 0, 1.0)", weight: 8.0}
    - {expr: "clip((met['butyrate'] - 7.0) / 1.0, 0, 1.0)", weight: 10.0}

    # Gentle bonus for finishing above 8 (linear overshoot)
    - {expr: "clip(met['butyrate'] - 8.0, 0, 1e9)", weight: 6.0}

    # ~6-point penalty for ending below 6 (linear shortfall up to 1)
    - {expr: "clip((6.0 - met['butyrate']) / 1.0, 0, 1.0)", weight: -6.0}

    # Extremely high cost for ending below 5 (binary-style extra hit)
    - {expr: "clip(5.0 - met['butyrate'], 0, 1.0)", weight: -80.0}




# Keep short-only randomization as in parity
init_randomization:
  enabled: true
  apply_to: short
  metabolites:
    - {pattern: ".*", low: 0.0, high: 8.0}
